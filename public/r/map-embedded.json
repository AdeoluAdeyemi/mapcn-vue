{
  "name": "map",
  "type": "registry:ui",
  "dependencies": [
    "maplibre-gl",
    "@vueuse/core",
    "lucide-vue-next"
  ],
  "files": [
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL, { type ProjectionSpecification, type MapOptions } from 'maplibre-gl'\nimport 'maplibre-gl/dist/maplibre-gl.css'\nimport { ref, onMounted, onUnmounted, provide, watch, computed } from 'vue'\nimport { useDark } from '@vueuse/core'\n\ntype MapStyleOption = string | MapLibreGL.StyleSpecification\n\ninterface MapProps {\n  styles?: {\n    light?: MapStyleOption\n    dark?: MapStyleOption\n  }\n  projection?: ProjectionSpecification\n}\n\nconst props = withDefaults(defineProps<MapProps & Partial<Omit<MapOptions, 'container' | 'style'>>>(), {\n  center: () => [0, 0] as [number, number],\n  zoom: 2\n})\n\nconst defaultStyles = {\n  dark: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',\n  light: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'\n}\n\nconst containerRef = ref<HTMLDivElement | null>(null)\nconst mapInstance = ref<MapLibreGL.Map | null>(null)\nconst isLoaded = ref(false)\nconst isStyleLoaded = ref(false)\nconst isDark = useDark()\n\nconst mapStyles = computed(() => ({\n  dark: props.styles?.dark ?? defaultStyles.dark,\n  light: props.styles?.light ?? defaultStyles.light\n}))\n\nconst isLoading = computed(() => !isLoaded.value || !isStyleLoaded.value)\n\nlet styleTimeout: ReturnType<typeof setTimeout> | null = null\n\nconst clearStyleTimeout = () => {\n  if (styleTimeout) {\n    clearTimeout(styleTimeout)\n    styleTimeout = null\n  }\n}\n\n// Provide map instance and loaded state to children\nprovide('map', mapInstance)\nprovide('isMapLoaded', computed(() => isLoaded.value && isStyleLoaded.value))\n\ndefineExpose({\n  map: mapInstance\n})\n\nonMounted(() => {\n  if (!containerRef.value) return\n\n  const initialStyle = isDark.value ? mapStyles.value.dark : mapStyles.value.light\n  let currentStyle = initialStyle\n\n  const map = new MapLibreGL.Map({\n    container: containerRef.value,\n    style: initialStyle,\n    center: props.center as [number, number],\n    zoom: props.zoom as number,\n    renderWorldCopies: false,\n    attributionControl: {\n      compact: true\n    }\n  })\n\n  const styleDataHandler = () => {\n    clearStyleTimeout()\n    styleTimeout = setTimeout(() => {\n      isStyleLoaded.value = true\n      if (props.projection) {\n        map.setProjection(props.projection)\n      }\n    }, 150)\n  }\n\n  const loadHandler = () => {\n    isLoaded.value = true\n  }\n\n  map.on('load', loadHandler)\n  map.on('styledata', styleDataHandler)\n  mapInstance.value = map\n\n  // Watch for theme changes\n  watch(isDark, (newIsDark) => {\n    if (!map) return\n\n    const newStyle = newIsDark ? mapStyles.value.dark : mapStyles.value.light\n\n    if (currentStyle === newStyle) return\n\n    clearStyleTimeout()\n    currentStyle = newStyle\n    isStyleLoaded.value = false\n\n    map.setStyle(newStyle, { diff: true })\n  })\n})\n\nonUnmounted(() => {\n  clearStyleTimeout()\n  if (mapInstance.value) {\n    mapInstance.value.remove()\n  }\n  isLoaded.value = false\n  isStyleLoaded.value = false\n  mapInstance.value = null\n})\n</script>\n\n<template>\n  <div ref=\"containerRef\" class=\"relative w-full h-full\">\n    <div v-if=\"isLoading\" class=\"absolute inset-0 flex items-center justify-center\">\n      <div class=\"flex gap-1\">\n        <span class=\"size-1.5 rounded-full bg-muted-foreground/60 animate-pulse\" />\n        <span class=\"size-1.5 rounded-full bg-muted-foreground/60 animate-pulse [animation-delay:150ms]\" />\n        <span class=\"size-1.5 rounded-full bg-muted-foreground/60 animate-pulse [animation-delay:300ms]\" />\n      </div>\n    </div>\n    <template v-if=\"mapInstance\">\n      <slot />\n    </template>\n  </div>\n</template>\n",
      "path": "r/map/Map.vue",
      "target": "components/map/Map.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { inject, onUnmounted, watch, computed, ref, type Ref, type ComputedRef } from 'vue'\n\ntype GeoJSONFeature = GeoJSON.Feature<GeoJSON.Point, any>\ntype FeatureCollection = GeoJSON.FeatureCollection<GeoJSON.Point, any>\n\ninterface MapClusterLayerProps {\n  data: string | FeatureCollection\n  clusterMaxZoom?: number\n  clusterRadius?: number\n  clusterColors?: [string, string, string]\n  clusterThresholds?: [number, number]\n  pointColor?: string\n}\n\nconst props = withDefaults(defineProps<MapClusterLayerProps>(), {\n  clusterMaxZoom: 14,\n  clusterRadius: 50,\n  clusterColors: () => ['#51bbd6', '#f1f075', '#f28cb1'],\n  clusterThresholds: () => [100, 750],\n  pointColor: '#3b82f6'\n})\n\nconst emit = defineEmits<{\n  pointClick: [feature: GeoJSONFeature, coordinates: [number, number]]\n  clusterClick: [clusterId: number, coordinates: [number, number], pointCount: number]\n}>()\n\nconst map = inject<Ref<MapLibreGL.Map | null>>('map')\nconst isLoaded = inject<ComputedRef<boolean>>('isMapLoaded')\n\nconst generateId = () => `cluster-${Math.random().toString(36).substr(2, 9)}`\nconst id = computed(() => generateId())\nconst sourceId = computed(() => `cluster-source-${id.value}`)\nconst clusterLayerId = computed(() => `clusters-${id.value}`)\nconst clusterCountLayerId = computed(() => `cluster-count-${id.value}`)\nconst unclusteredLayerId = computed(() => `unclustered-point-${id.value}`)\n\nconst isInitialized = ref(false)\n\nconst initializeLayers = () => {\n  if (!map?.value || isInitialized.value) return\n\n  const mapInstance = map.value\n\n  // Add source\n  mapInstance.addSource(sourceId.value, {\n    type: 'geojson',\n    data: props.data,\n    cluster: true,\n    clusterMaxZoom: props.clusterMaxZoom,\n    clusterRadius: props.clusterRadius\n  })\n\n  // Add cluster circles layer\n  mapInstance.addLayer({\n    id: clusterLayerId.value,\n    type: 'circle',\n    source: sourceId.value,\n    filter: ['has', 'point_count'],\n    paint: {\n      'circle-color': [\n        'step',\n        ['get', 'point_count'],\n        props.clusterColors[0],\n        props.clusterThresholds[0],\n        props.clusterColors[1],\n        props.clusterThresholds[1],\n        props.clusterColors[2]\n      ],\n      'circle-radius': [\n        'step',\n        ['get', 'point_count'],\n        20,\n        props.clusterThresholds[0],\n        30,\n        props.clusterThresholds[1],\n        40\n      ]\n    }\n  })\n\n  // Add cluster count text layer\n  mapInstance.addLayer({\n    id: clusterCountLayerId.value,\n    type: 'symbol',\n    source: sourceId.value,\n    filter: ['has', 'point_count'],\n    layout: {\n      'text-field': '{point_count_abbreviated}',\n      'text-size': 12\n    },\n    paint: {\n      'text-color': '#fff'\n    }\n  })\n\n  // Add unclustered point layer\n  mapInstance.addLayer({\n    id: unclusteredLayerId.value,\n    type: 'circle',\n    source: sourceId.value,\n    filter: ['!', ['has', 'point_count']],\n    paint: {\n      'circle-color': props.pointColor,\n      'circle-radius': 6\n    }\n  })\n\n  // Event handlers\n  const handleClusterClick = async (e: MapLibreGL.MapMouseEvent & { features?: MapLibreGL.MapGeoJSONFeature[] }) => {\n    const features = mapInstance.queryRenderedFeatures(e.point, {\n      layers: [clusterLayerId.value]\n    })\n    if (!features.length) return\n\n    const feature = features[0]\n    const clusterId = feature.properties?.cluster_id as number\n    const pointCount = feature.properties?.point_count as number\n    const coordinates = (feature.geometry as GeoJSON.Point).coordinates as [number, number]\n\n    emit('clusterClick', clusterId, coordinates, pointCount)\n\n    // Default behavior: zoom to cluster\n    const source = mapInstance.getSource(sourceId.value) as MapLibreGL.GeoJSONSource\n    const zoom = await source.getClusterExpansionZoom(clusterId)\n    mapInstance.easeTo({ center: coordinates, zoom })\n  }\n\n  const handlePointClick = (e: MapLibreGL.MapMouseEvent & { features?: MapLibreGL.MapGeoJSONFeature[] }) => {\n    if (!e.features?.length) return\n\n    const feature = e.features[0]\n    const coordinates = (feature.geometry as GeoJSON.Point).coordinates.slice() as [number, number]\n\n    // Handle world copies\n    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n      coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360\n    }\n\n    emit('pointClick', feature as unknown as GeoJSONFeature, coordinates)\n  }\n\n  const handleMouseEnterCluster = () => {\n    mapInstance.getCanvas().style.cursor = 'pointer'\n  }\n\n  const handleMouseLeaveCluster = () => {\n    mapInstance.getCanvas().style.cursor = ''\n  }\n\n  const handleMouseEnterPoint = () => {\n    mapInstance.getCanvas().style.cursor = 'pointer'\n  }\n\n  const handleMouseLeavePoint = () => {\n    mapInstance.getCanvas().style.cursor = ''\n  }\n\n  mapInstance.on('click', clusterLayerId.value, handleClusterClick)\n  mapInstance.on('click', unclusteredLayerId.value, handlePointClick)\n  mapInstance.on('mouseenter', clusterLayerId.value, handleMouseEnterCluster)\n  mapInstance.on('mouseleave', clusterLayerId.value, handleMouseLeaveCluster)\n  mapInstance.on('mouseenter', unclusteredLayerId.value, handleMouseEnterPoint)\n  mapInstance.on('mouseleave', unclusteredLayerId.value, handleMouseLeavePoint)\n\n  isInitialized.value = true\n}\n\n// Watch for map to be loaded\nwatch(isLoaded ?? ref(false), (loaded) => {\n  if (loaded) {\n    initializeLayers()\n  }\n}, { immediate: true })\n\nonUnmounted(() => {\n  if (!map?.value || !isInitialized.value) return\n  \n  const mapInstance = map.value\n  try {\n    if (mapInstance.getLayer(clusterCountLayerId.value)) mapInstance.removeLayer(clusterCountLayerId.value)\n    if (mapInstance.getLayer(unclusteredLayerId.value)) mapInstance.removeLayer(unclusteredLayerId.value)\n    if (mapInstance.getLayer(clusterLayerId.value)) mapInstance.removeLayer(clusterLayerId.value)\n    if (mapInstance.getSource(sourceId.value)) mapInstance.removeSource(sourceId.value)\n  } catch {\n    // ignore\n  }\n})\n\n// Update data when prop changes\nwatch(() => props.data, (data) => {\n  if (!isInitialized.value || !map?.value || typeof data === 'string') return\n\n  const source = map.value.getSource(sourceId.value) as MapLibreGL.GeoJSONSource\n  if (source) {\n    source.setData(data)\n  }\n})\n\n// Update styles\nwatch(() => [props.clusterColors, props.clusterThresholds, props.pointColor], () => {\n  if (!isInitialized.value || !map?.value) return\n\n  if (map.value.getLayer(clusterLayerId.value)) {\n    map.value.setPaintProperty(clusterLayerId.value, 'circle-color', [\n      'step',\n      ['get', 'point_count'],\n      props.clusterColors[0],\n      props.clusterThresholds[0],\n      props.clusterColors[1],\n      props.clusterThresholds[1],\n      props.clusterColors[2]\n    ])\n    map.value.setPaintProperty(clusterLayerId.value, 'circle-radius', [\n      'step',\n      ['get', 'point_count'],\n      20,\n      props.clusterThresholds[0],\n      30,\n      props.clusterThresholds[1],\n      40\n    ])\n  }\n\n  if (map.value.getLayer(unclusteredLayerId.value)) {\n    map.value.setPaintProperty(unclusteredLayerId.value, 'circle-color', props.pointColor)\n  }\n})\n</script>\n\n<template>\n  <!-- Cluster layer is rendered directly to the map, no template needed -->\n</template>\n",
      "path": "r/map/MapClusterLayer.vue",
      "target": "components/map/MapClusterLayer.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { ref, inject, onMounted, onUnmounted, type Ref, type ComputedRef } from 'vue'\nimport { Plus, Minus, Locate, Maximize, Loader2 } from 'lucide-vue-next'\nimport { cn } from '@/lib/utils'\n\ninterface MapControlsProps {\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  showZoom?: boolean\n  showCompass?: boolean\n  showLocate?: boolean\n  showFullscreen?: boolean\n  className?: string\n}\n\nconst props = withDefaults(defineProps<MapControlsProps>(), {\n  position: 'bottom-right',\n  showZoom: true,\n  showCompass: false,\n  showLocate: false,\n  showFullscreen: false\n})\n\nconst emit = defineEmits<{\n  locate: [coords: { longitude: number; latitude: number }]\n}>()\n\nconst map = inject<Ref<MapLibreGL.Map | null>>('map')\nconst isLoaded = inject<ComputedRef<boolean>>('isMapLoaded')\nconst waitingForLocation = ref(false)\nconst compassRef = ref<SVGSVGElement | null>(null)\n\nconst positionClasses = {\n  'top-left': 'top-2 left-2',\n  'top-right': 'top-2 right-2',\n  'bottom-left': 'bottom-2 left-2',\n  'bottom-right': 'bottom-10 right-2'\n}\n\nconst handleZoomIn = () => {\n  if (map?.value) {\n    map.value.zoomTo(map.value.getZoom() + 1, { duration: 300 })\n  }\n}\n\nconst handleZoomOut = () => {\n  if (map?.value) {\n    map.value.zoomTo(map.value.getZoom() - 1, { duration: 300 })\n  }\n}\n\nconst handleResetBearing = () => {\n  if (map?.value) {\n    map.value.resetNorthPitch({ duration: 300 })\n  }\n}\n\nconst handleLocate = () => {\n  waitingForLocation.value = true\n  if ('geolocation' in navigator) {\n    navigator.geolocation.getCurrentPosition(\n      (pos) => {\n        const coords = {\n          longitude: pos.coords.longitude,\n          latitude: pos.coords.latitude\n        }\n        map?.value?.flyTo({\n          center: [coords.longitude, coords.latitude],\n          zoom: 14,\n          duration: 1500\n        })\n        emit('locate', coords)\n        waitingForLocation.value = false\n      },\n      (error) => {\n        console.error('Error getting location:', error)\n        waitingForLocation.value = false\n      }\n    )\n  }\n}\n\nconst handleFullscreen = () => {\n  const container = map?.value?.getContainer()\n  if (!container) return\n  if (document.fullscreenElement) {\n    document.exitFullscreen()\n  } else {\n    container.requestFullscreen()\n  }\n}\n\n// Compass rotation effect\nonMounted(() => {\n  if (!props.showCompass || !isLoaded?.value || !map?.value || !compassRef.value) return\n\n  const compass = compassRef.value\n  const mapInstance = map.value\n\n  const updateRotation = () => {\n    const bearing = mapInstance.getBearing()\n    const pitch = mapInstance.getPitch()\n    compass.style.transform = `rotateX(${pitch}deg) rotateZ(${-bearing}deg)`\n  }\n\n  mapInstance.on('rotate', updateRotation)\n  mapInstance.on('pitch', updateRotation)\n  updateRotation()\n\n  onUnmounted(() => {\n    mapInstance.off('rotate', updateRotation)\n    mapInstance.off('pitch', updateRotation)\n  })\n})\n</script>\n\n<template>\n  <div\n    v-if=\"isLoaded\"\n    :class=\"cn(\n      'absolute z-10 flex flex-col gap-1.5',\n      positionClasses[position],\n      className\n    )\"\n  >\n    <!-- Zoom controls -->\n    <div v-if=\"showZoom\" class=\"flex flex-col rounded-md border border-border bg-background shadow-sm overflow-hidden\">\n      <button\n        @click=\"handleZoomIn\"\n        aria-label=\"Zoom in\"\n        type=\"button\"\n        class=\"flex items-center justify-center size-8 hover:bg-accent dark:hover:bg-accent/40 transition-colors border-b border-border\"\n      >\n        <Plus class=\"size-4\" />\n      </button>\n      <button\n        @click=\"handleZoomOut\"\n        aria-label=\"Zoom out\"\n        type=\"button\"\n        class=\"flex items-center justify-center size-8 hover:bg-accent dark:hover:bg-accent/40 transition-colors\"\n      >\n        <Minus class=\"size-4\" />\n      </button>\n    </div>\n\n    <!-- Compass control -->\n    <div v-if=\"showCompass\" class=\"flex flex-col rounded-md border border-border bg-background shadow-sm overflow-hidden\">\n      <button\n        @click=\"handleResetBearing\"\n        aria-label=\"Reset bearing to north\"\n        type=\"button\"\n        class=\"flex items-center justify-center size-8 hover:bg-accent dark:hover:bg-accent/40 transition-colors\"\n      >\n        <svg\n          ref=\"compassRef\"\n          viewBox=\"0 0 24 24\"\n          class=\"size-5 transition-transform duration-200\"\n          style=\"transform-style: preserve-3d\"\n        >\n          <path d=\"M12 2L16 12H12V2Z\" class=\"fill-red-500\" />\n          <path d=\"M12 2L8 12H12V2Z\" class=\"fill-red-300\" />\n          <path d=\"M12 22L16 12H12V22Z\" class=\"fill-muted-foreground/60\" />\n          <path d=\"M12 22L8 12H12V22Z\" class=\"fill-muted-foreground/30\" />\n        </svg>\n      </button>\n    </div>\n\n    <!-- Locate control -->\n    <div v-if=\"showLocate\" class=\"flex flex-col rounded-md border border-border bg-background shadow-sm overflow-hidden\">\n      <button\n        @click=\"handleLocate\"\n        aria-label=\"Find my location\"\n        type=\"button\"\n        :disabled=\"waitingForLocation\"\n        :class=\"cn(\n          'flex items-center justify-center size-8 hover:bg-accent dark:hover:bg-accent/40 transition-colors',\n          waitingForLocation && 'opacity-50 pointer-events-none cursor-not-allowed'\n        )\"\n      >\n        <Loader2 v-if=\"waitingForLocation\" class=\"size-4 animate-spin\" />\n        <Locate v-else class=\"size-4\" />\n      </button>\n    </div>\n\n    <!-- Fullscreen control -->\n    <div v-if=\"showFullscreen\" class=\"flex flex-col rounded-md border border-border bg-background shadow-sm overflow-hidden\">\n      <button\n        @click=\"handleFullscreen\"\n        aria-label=\"Toggle fullscreen\"\n        type=\"button\"\n        class=\"flex items-center justify-center size-8 hover:bg-accent dark:hover:bg-accent/40 transition-colors\"\n      >\n        <Maximize class=\"size-4\" />\n      </button>\n    </div>\n  </div>\n</template>\n",
      "path": "r/map/MapControls.vue",
      "target": "components/map/MapControls.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { ref, inject, onUnmounted, provide, watch, type Ref, type ComputedRef } from 'vue'\n\ninterface MapMarkerProps {\n  longitude: number\n  latitude: number\n  draggable?: boolean\n  offset?: [number, number]\n  rotation?: number\n  rotationAlignment?: 'map' | 'viewport' | 'auto'\n  pitchAlignment?: 'map' | 'viewport' | 'auto'\n}\n\nconst props = withDefaults(defineProps<MapMarkerProps>(), {\n  draggable: false,\n  rotation: 0,\n  rotationAlignment: 'auto',\n  pitchAlignment: 'auto'\n})\n\nconst emit = defineEmits<{\n  click: [e: MouseEvent]\n  mouseenter: [e: MouseEvent]\n  mouseleave: [e: MouseEvent]\n  dragStart: [lngLat: { lng: number; lat: number }]\n  drag: [lngLat: { lng: number; lat: number }]\n  dragEnd: [lngLat: { lng: number; lat: number }]\n}>()\n\nconst map = inject<Ref<MapLibreGL.Map | null>>('map')\nconst isLoaded = inject<ComputedRef<boolean>>('isMapLoaded')\nconst markerRef = ref<HTMLDivElement | null>(null)\nconst marker = ref<MapLibreGL.Marker | null>(null)\n\n// Provide marker instance to children\nprovide('marker', marker)\nprovide('markerMap', map)\n\nconst initializeMarker = () => {\n  if (!map?.value || !markerRef.value || marker.value) return\n\n  const markerInstance = new MapLibreGL.Marker({\n    element: markerRef.value,\n    draggable: props.draggable,\n    offset: props.offset,\n    rotation: props.rotation,\n    rotationAlignment: props.rotationAlignment,\n    pitchAlignment: props.pitchAlignment\n  }).setLngLat([props.longitude, props.latitude])\n\n  // Event listeners\n  markerRef.value.addEventListener('click', (e) => emit('click', e))\n  markerRef.value.addEventListener('mouseenter', (e) => emit('mouseenter', e))\n  markerRef.value.addEventListener('mouseleave', (e) => emit('mouseleave', e))\n\n  markerInstance.on('dragstart', () => {\n    const lngLat = markerInstance.getLngLat()\n    emit('dragStart', { lng: lngLat.lng, lat: lngLat.lat })\n  })\n\n  markerInstance.on('drag', () => {\n    const lngLat = markerInstance.getLngLat()\n    emit('drag', { lng: lngLat.lng, lat: lngLat.lat })\n  })\n\n  markerInstance.on('dragend', () => {\n    const lngLat = markerInstance.getLngLat()\n    emit('dragEnd', { lng: lngLat.lng, lat: lngLat.lat })\n  })\n\n  markerInstance.addTo(map.value)\n  marker.value = markerInstance\n}\n\n// Wait for map to be loaded and ref to be ready\nwatch([isLoaded ?? ref(false), markerRef], ([loaded]) => {\n  if (loaded && markerRef.value) {\n    initializeMarker()\n  }\n})\n\n// Watch for prop changes\nwatch(() => [props.longitude, props.latitude], ([lng, lat]) => {\n  if (marker.value) {\n    marker.value.setLngLat([lng as number, lat as number])\n  }\n})\n\nwatch(() => props.draggable, (draggable) => {\n  if (marker.value) {\n    marker.value.setDraggable(draggable)\n  }\n})\n\nwatch(() => props.offset, (offset) => {\n  if (marker.value && offset) {\n    marker.value.setOffset(offset)\n  }\n})\n\nwatch(() => props.rotation, (rotation) => {\n  if (marker.value) {\n    marker.value.setRotation(rotation)\n  }\n})\n\nwatch(() => props.rotationAlignment, (alignment) => {\n  if (marker.value) {\n    marker.value.setRotationAlignment(alignment)\n  }\n})\n\nwatch(() => props.pitchAlignment, (alignment) => {\n  if (marker.value) {\n    marker.value.setPitchAlignment(alignment)\n  }\n})\n\nonUnmounted(() => {\n  if (marker.value) {\n    marker.value.remove()\n  }\n})\n</script>\n\n<template>\n  <div ref=\"markerRef\">\n    <slot />\n  </div>\n</template>\n",
      "path": "r/map/MapMarker.vue",
      "target": "components/map/MapMarker.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { ref, inject, onMounted, onUnmounted, watch, type Ref } from 'vue'\nimport { X } from 'lucide-vue-next'\nimport { cn } from '@/lib/utils'\n\ninterface MapPopupProps {\n  longitude: number\n  latitude: number\n  className?: string\n  closeButton?: boolean\n  offset?: number | [number, number]\n  maxWidth?: string\n}\n\nconst props = withDefaults(defineProps<MapPopupProps>(), {\n  closeButton: false,\n  offset: 16,\n  maxWidth: 'none'\n})\n\nconst emit = defineEmits<{\n  close: []\n}>()\n\nconst map = inject<Ref<MapLibreGL.Map | null>>('map')\nconst containerRef = ref<HTMLDivElement | null>(null)\nconst popup = ref<MapLibreGL.Popup | null>(null)\n\nonMounted(() => {\n  if (!map?.value) return\n\n  const container = document.createElement('div')\n  containerRef.value = container\n\n  const popupInstance = new MapLibreGL.Popup({\n    offset: props.offset,\n    maxWidth: props.maxWidth,\n    closeButton: false\n  })\n    .setMaxWidth('none')\n    .setLngLat([props.longitude, props.latitude])\n    .setDOMContent(container)\n\n  popupInstance.on('close', () => emit('close'))\n  popupInstance.addTo(map.value)\n  popup.value = popupInstance\n})\n\nwatch(() => [props.longitude, props.latitude], ([lng, lat]) => {\n  if (popup.value && popup.value.isOpen()) {\n    popup.value.setLngLat([lng as number, lat as number])\n  }\n})\n\nwatch(() => props.offset, (offset) => {\n  if (popup.value && popup.value.isOpen()) {\n    popup.value.setOffset(offset)\n  }\n})\n\nwatch(() => props.maxWidth, (maxWidth) => {\n  if (popup.value && popup.value.isOpen() && maxWidth) {\n    popup.value.setMaxWidth(maxWidth)\n  }\n})\n\nconst handleClose = () => {\n  if (popup.value) {\n    popup.value.remove()\n    emit('close')\n  }\n}\n\nonUnmounted(() => {\n  if (popup.value && popup.value.isOpen()) {\n    popup.value.remove()\n  }\n})\n</script>\n\n<template>\n  <Teleport v-if=\"containerRef\" :to=\"containerRef\">\n    <div\n      :class=\"cn(\n        'relative rounded-md border bg-popover p-3 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95',\n        className\n      )\"\n    >\n      <button\n        v-if=\"closeButton\"\n        type=\"button\"\n        @click=\"handleClose\"\n        class=\"absolute top-1 right-1 z-10 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\"\n        aria-label=\"Close popup\"\n      >\n        <X class=\"h-4 w-4\" />\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <slot />\n    </div>\n  </Teleport>\n</template>\n",
      "path": "r/map/MapPopup.vue",
      "target": "components/map/MapPopup.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { inject, onUnmounted, watch, computed, ref, type Ref, type ComputedRef } from 'vue'\n\ninterface MapRouteProps {\n  id?: string\n  coordinates: [number, number][]\n  color?: string\n  width?: number\n  opacity?: number\n  dashArray?: [number, number]\n  interactive?: boolean\n}\n\nconst props = withDefaults(defineProps<MapRouteProps>(), {\n  color: '#4285F4',\n  width: 3,\n  opacity: 0.8,\n  interactive: true\n})\n\nconst emit = defineEmits<{\n  click: []\n  mouseenter: []\n  mouseleave: []\n}>()\n\nconst map = inject<Ref<MapLibreGL.Map | null>>('map')\nconst isLoaded = inject<ComputedRef<boolean>>('isMapLoaded')\n\nconst generateId = () => `route-${Math.random().toString(36).substr(2, 9)}`\nconst id = computed(() => props.id || generateId())\nconst sourceId = computed(() => `route-source-${id.value}`)\nconst layerId = computed(() => `route-layer-${id.value}`)\n\nconst isInitialized = ref(false)\n\nconst initializeRoute = () => {\n  if (!map?.value || isInitialized.value) return\n\n  const mapInstance = map.value\n\n  // Add source\n  mapInstance.addSource(sourceId.value, {\n    type: 'geojson',\n    data: {\n      type: 'Feature',\n      properties: {},\n      geometry: { type: 'LineString', coordinates: props.coordinates }\n    }\n  })\n\n  // Add layer\n  mapInstance.addLayer({\n    id: layerId.value,\n    type: 'line',\n    source: sourceId.value,\n    layout: { 'line-join': 'round', 'line-cap': 'round' },\n    paint: {\n      'line-color': props.color,\n      'line-width': props.width,\n      'line-opacity': props.opacity,\n      ...(props.dashArray && { 'line-dasharray': props.dashArray })\n    }\n  })\n\n  // Event handlers\n  const handleClick = () => emit('click')\n  const handleMouseEnter = () => {\n    mapInstance.getCanvas().style.cursor = 'pointer'\n    emit('mouseenter')\n  }\n  const handleMouseLeave = () => {\n    mapInstance.getCanvas().style.cursor = ''\n    emit('mouseleave')\n  }\n\n  if (props.interactive) {\n    mapInstance.on('click', layerId.value, handleClick)\n    mapInstance.on('mouseenter', layerId.value, handleMouseEnter)\n    mapInstance.on('mouseleave', layerId.value, handleMouseLeave)\n  }\n\n  isInitialized.value = true\n}\n\n// Watch for map to be loaded\nwatch(isLoaded ?? ref(false), (loaded) => {\n  if (loaded) {\n    initializeRoute()\n  }\n}, { immediate: true })\n\nonUnmounted(() => {\n  if (!map?.value || !isInitialized.value) return\n  \n  const mapInstance = map.value\n  try {\n    if (mapInstance.getLayer(layerId.value)) mapInstance.removeLayer(layerId.value)\n    if (mapInstance.getSource(sourceId.value)) mapInstance.removeSource(sourceId.value)\n  } catch {\n    // ignore\n  }\n})\n\n// Update coordinates\nwatch(() => props.coordinates, (coordinates) => {\n  if (!isInitialized.value || !map?.value || coordinates.length < 2) return\n\n  const source = map.value.getSource(sourceId.value) as MapLibreGL.GeoJSONSource\n  if (source) {\n    source.setData({\n      type: 'Feature',\n      properties: {},\n      geometry: { type: 'LineString', coordinates }\n    })\n  }\n})\n\n// Update styles\nwatch(() => [props.color, props.width, props.opacity, props.dashArray], () => {\n  if (!isInitialized.value || !map?.value || !map.value.getLayer(layerId.value)) return\n\n  map.value.setPaintProperty(layerId.value, 'line-color', props.color)\n  map.value.setPaintProperty(layerId.value, 'line-width', props.width)\n  map.value.setPaintProperty(layerId.value, 'line-opacity', props.opacity)\n  if (props.dashArray) {\n    map.value.setPaintProperty(layerId.value, 'line-dasharray', props.dashArray)\n  }\n})\n</script>\n\n<template>\n  <!-- Route is rendered directly to the map, no template needed -->\n</template>\n",
      "path": "r/map/MapRoute.vue",
      "target": "components/map/MapRoute.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport { TrendingUp, TrendingDown } from 'lucide-vue-next'\nimport { computed } from 'vue'\n\ninterface MapStatCardProps {\n  title: string\n  value: string | number\n  change?: number\n  changeLabel?: string\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n}\n\nconst props = withDefaults(defineProps<MapStatCardProps>(), {\n  position: 'top-left',\n  changeLabel: 'vs last hour'\n})\n\nconst positionClass = computed(() => {\n  const positions = {\n    'top-left': 'top-3 left-3',\n    'top-right': 'top-3 right-3',\n    'bottom-left': 'bottom-3 left-3',\n    'bottom-right': 'bottom-3 right-3'\n  }\n  return positions[props.position]\n})\n\nconst isPositive = computed(() => props.change && props.change > 0)\nconst changeColor = computed(() => isPositive.value ? 'text-emerald-500' : 'text-red-500')\n</script>\n\n<template>\n  <div \n    :class=\"['absolute z-10 bg-background/95 backdrop-blur-md rounded-lg p-3 border border-border/50 shadow-lg', positionClass]\"\n  >\n    <div class=\"tracking-wider text-[10px] text-muted-foreground uppercase mb-1\">\n      {{ title }}\n    </div>\n    <div class=\"text-2xl font-semibold leading-tight\">\n      {{ value }}\n    </div>\n    <div v-if=\"change !== undefined\" class=\"flex items-center gap-1 mt-1\">\n      <TrendingUp v-if=\"isPositive\" :class=\"['size-3', changeColor]\" aria-hidden=\"true\" />\n      <TrendingDown v-else :class=\"['size-3', changeColor]\" aria-hidden=\"true\" />\n      <span :class=\"['text-xs', changeColor]\">\n        {{ isPositive ? '+' : '' }}{{ change }}%\n      </span>\n      <span class=\"text-xs text-muted-foreground\">{{ changeLabel }}</span>\n    </div>\n  </div>\n</template>\n",
      "path": "r/map/MapStatCard.vue",
      "target": "components/map/MapStatCard.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport { inject, type Ref } from 'vue'\nimport MapLibreGL from 'maplibre-gl'\nimport { cn } from '@/lib/utils'\n\ninterface MarkerContentProps {\n  className?: string\n}\n\ndefineProps<MarkerContentProps>()\n\nconst marker = inject<Ref<MapLibreGL.Marker | null>>('marker')\n</script>\n\n<template>\n  <Teleport v-if=\"marker\" :to=\"marker.getElement()\">\n    <div :class=\"cn('relative cursor-pointer', className)\">\n      <slot>\n        <!-- Default marker icon with pulse animation -->\n        <div class=\"relative flex items-center justify-center\">\n          <div class=\"absolute rounded-full bg-emerald-500/20\" style=\"width: 22.5px; height: 22.5px;\" />\n          <div class=\"absolute rounded-full bg-emerald-500/40 animate-ping\" style=\"width: 13.5px; height: 13.5px; animation-duration: 2s;\" />\n          <div class=\"relative rounded-full bg-emerald-500 shadow-lg shadow-emerald-500/50\" style=\"width: 9px; height: 9px;\" />\n        </div>\n      </slot>\n    </div>\n  </Teleport>\n</template>\n",
      "path": "r/map/MarkerContent.vue",
      "target": "components/map/MarkerContent.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils'\n\ninterface MarkerLabelProps {\n  className?: string\n  position?: 'top' | 'bottom'\n}\n\nwithDefaults(defineProps<MarkerLabelProps>(), {\n  position: 'top'\n})\n\nconst positionClasses = {\n  top: 'bottom-full mb-1',\n  bottom: 'top-full mt-1'\n}\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'absolute left-1/2 -translate-x-1/2 whitespace-nowrap',\n      'text-[10px] font-medium text-foreground',\n      positionClasses[position],\n      className\n    )\"\n  >\n    <slot />\n  </div>\n</template>\n",
      "path": "r/map/MarkerLabel.vue",
      "target": "components/map/MarkerLabel.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { ref, inject, onMounted, onUnmounted, watch, type Ref } from 'vue'\nimport { X } from 'lucide-vue-next'\nimport { cn } from '@/lib/utils'\n\ninterface MarkerPopupProps {\n  className?: string\n  closeButton?: boolean\n  offset?: number | [number, number]\n  maxWidth?: string\n}\n\nconst props = withDefaults(defineProps<MarkerPopupProps>(), {\n  closeButton: false,\n  offset: 16,\n  maxWidth: 'none'\n})\n\nconst marker = inject<Ref<MapLibreGL.Marker | null>>('marker')\nconst map = inject<Ref<MapLibreGL.Map | null>>('markerMap')\nconst containerRef = ref<HTMLDivElement | null>(null)\nconst popup = ref<MapLibreGL.Popup | null>(null)\n\nonMounted(() => {\n  if (!map?.value || !marker?.value) return\n\n  const container = document.createElement('div')\n  containerRef.value = container\n\n  const popupInstance = new MapLibreGL.Popup({\n    offset: props.offset,\n    maxWidth: props.maxWidth,\n    closeButton: false\n  }).setMaxWidth('none').setDOMContent(container)\n\n  marker.value.setPopup(popupInstance)\n  popup.value = popupInstance\n})\n\nwatch(() => props.offset, (offset) => {\n  if (popup.value && popup.value.isOpen()) {\n    popup.value.setOffset(offset)\n  }\n})\n\nwatch(() => props.maxWidth, (maxWidth) => {\n  if (popup.value && popup.value.isOpen() && maxWidth) {\n    popup.value.setMaxWidth(maxWidth)\n  }\n})\n\nconst handleClose = () => {\n  if (popup.value) {\n    popup.value.remove()\n  }\n}\n\nonUnmounted(() => {\n  if (marker?.value) {\n    marker.value.setPopup(null)\n  }\n})\n</script>\n\n<template>\n  <Teleport v-if=\"containerRef\" :to=\"containerRef\">\n    <div\n      :class=\"cn(\n        'relative rounded-md border bg-popover p-3 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95',\n        className\n      )\"\n    >\n      <button\n        v-if=\"closeButton\"\n        type=\"button\"\n        @click=\"handleClose\"\n        class=\"absolute top-1 right-1 z-10 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\"\n        aria-label=\"Close popup\"\n      >\n        <X class=\"h-4 w-4\" />\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <slot />\n    </div>\n  </Teleport>\n</template>\n",
      "path": "r/map/MarkerPopup.vue",
      "target": "components/map/MarkerPopup.vue"
    },
    {
      "type": "registry:ui",
      "content": "<script setup lang=\"ts\">\nimport MapLibreGL from 'maplibre-gl'\nimport { ref, inject, onMounted, onUnmounted, watch, type Ref } from 'vue'\nimport { cn } from '@/lib/utils'\n\ninterface MarkerTooltipProps {\n  className?: string\n  offset?: number | [number, number]\n  maxWidth?: string\n}\n\nconst props = withDefaults(defineProps<MarkerTooltipProps>(), {\n  offset: 16,\n  maxWidth: 'none'\n})\n\nconst marker = inject<Ref<MapLibreGL.Marker | null>>('marker')\nconst map = inject<Ref<MapLibreGL.Map | null>>('markerMap')\nconst containerRef = ref<HTMLDivElement | null>(null)\nconst tooltip = ref<MapLibreGL.Popup | null>(null)\n\nonMounted(() => {\n  if (!map?.value || !marker?.value) return\n\n  const container = document.createElement('div')\n  containerRef.value = container\n\n  const tooltipInstance = new MapLibreGL.Popup({\n    offset: props.offset,\n    maxWidth: props.maxWidth,\n    closeOnClick: true,\n    closeButton: false\n  }).setMaxWidth('none')\n\n  tooltip.value = tooltipInstance\n\n  const markerElement = marker.value.getElement()\n  if (markerElement) {\n    markerElement.addEventListener('mouseenter', () => {\n      if (marker.value && map.value) {\n        tooltipInstance.setDOMContent(container)\n        tooltipInstance.setLngLat(marker.value.getLngLat()).addTo(map.value)\n      }\n    })\n    markerElement.addEventListener('mouseleave', () => {\n      tooltipInstance.remove()\n    })\n  }\n})\n\nwatch(() => props.offset, (offset) => {\n  if (tooltip.value && tooltip.value.isOpen()) {\n    tooltip.value.setOffset(offset)\n  }\n})\n\nwatch(() => props.maxWidth, (maxWidth) => {\n  if (tooltip.value && tooltip.value.isOpen() && maxWidth) {\n    tooltip.value.setMaxWidth(maxWidth)\n  }\n})\n\nonUnmounted(() => {\n  if (tooltip.value) {\n    tooltip.value.remove()\n  }\n})\n</script>\n\n<template>\n  <Teleport v-if=\"containerRef\" :to=\"containerRef\">\n    <div\n      :class=\"cn(\n        'rounded-md bg-foreground px-2 py-1 text-xs text-background shadow-md animate-in fade-in-0 zoom-in-95',\n        className\n      )\"\n    >\n      <slot />\n    </div>\n  </Teleport>\n</template>\n",
      "path": "r/map/MarkerTooltip.vue",
      "target": "components/map/MarkerTooltip.vue"
    },
    {
      "type": "registry:ui",
      "content": "export { default as Map } from './Map.vue'\nexport { default as MapMarker } from './MapMarker.vue'\nexport { default as MarkerContent } from './MarkerContent.vue'\nexport { default as MarkerPopup } from './MarkerPopup.vue'\nexport { default as MarkerTooltip } from './MarkerTooltip.vue'\nexport { default as MarkerLabel } from './MarkerLabel.vue'\nexport { default as MapPopup } from './MapPopup.vue'\nexport { default as MapControls } from './MapControls.vue'\nexport { default as MapRoute } from './MapRoute.vue'\nexport { default as MapClusterLayer } from './MapClusterLayer.vue'\nexport { default as MapStatCard } from './MapStatCard.vue'\n",
      "path": "r/map/index.ts",
      "target": "components/map/index.ts"
    }
  ]
}